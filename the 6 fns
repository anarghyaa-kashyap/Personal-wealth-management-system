#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef enum { STOCK, GOLD, PROPERTY, NONE } InvestmentType;

typedef struct ExpenditureNode {
    char category[50];
    char description[100];
    double amount;
    InvestmentType invType;
    struct ExpenditureNode* next;
} ExpenditureNode;

typedef struct WealthNode {
    char name[50];
    double value;
    struct WealthNode* firstChild;
    struct WealthNode* nextSibling;
} WealthNode;

typedef struct UserProfile {
    char name[50];
    char gender[10];
    double netWorth;
    WealthNode* wealthRoot;
    ExpenditureNode* expenseHead;
} UserProfile;

/* Helper function to search a node in the tree */
WealthNode* findWealthNode(WealthNode* root, const char* nodeName) {
    if (!root || !nodeName) return NULL;
    if (strcmp(root->name, nodeName) == 0) return root;
    WealthNode* found = findWealthNode(root->firstChild, nodeName);
    if (found) return found;
    return findWealthNode(root->nextSibling, nodeName);
}

/* 1. Add a transaction to the user's linked list */
void logExpenseToList(UserProfile* user, const char* category, const char* desc, 
                      double amount, InvestmentType invType) {
    if (!user || !category || !desc || amount < 0) {
        printf("Invalid transaction details.\n");
        return;
    }
    ExpenditureNode* newNode = malloc(sizeof(ExpenditureNode));
    if (!newNode) {
        printf("Memory allocation failed.\n");
        return;
    }

    strcpy(newNode->category, category);
    strcpy(newNode->description, desc);
    newNode->amount = amount;
    newNode->invType = invType;
    newNode->next = user->expenseHead;
    user->expenseHead = newNode;

    printf("Transaction added: [%s] %s - %.2f\n", category, desc, amount);
}

/* 2. Update a specific investment's value in the tree */
void updateInvestmentValue(UserProfile* user, const char* nodeName, double newValue) {
    if (!user || !user->wealthRoot || !nodeName) {
        printf("Invalid input to updateInvestmentValue.\n");
        return;
    }
    WealthNode* node = findWealthNode(user->wealthRoot, nodeName);
    if (!node) {
        printf("Category '%s' not found.\n", nodeName);
        return;
    }
    if (newValue < 0) {
        printf("Negative value not allowed.\n");
        return;
    }
    node->value = newValue;
    printf("Updated '%s' to %.2f\n", nodeName, newValue);
}

/* 3. Add an expense to a specific category total in the tree */
void updateExpenseCategoryTotal(UserProfile* user, const char* category, double amount) {
    if (!user || !user->wealthRoot || !category) {
        printf("Invalid input to updateExpenseCategoryTotal.\n");
        return;
    }
    WealthNode* node = findWealthNode(user->wealthRoot, category);
    if (!node) {
        printf("Category '%s' not found.\n", category);
        return;
    }
    node->value += amount;
    printf("Added %.2f to '%s' (New Total: %.2f)\n", amount, category, node->value);
}

/* 4. Create and initialize a new user profile */
UserProfile* registerNewUser(const char* name, const char* gender) {
    if (!name || !gender) {
        printf("Invalid user details.\n");
        return NULL;
    }
    UserProfile* user = malloc(sizeof(UserProfile));
    if (!user) {
        printf("Memory allocation failed.\n");
        return NULL;
    }

    strcpy(user->name, name);
    strcpy(user->gender, gender);
    user->netWorth = 0.0;
    user->expenseHead = NULL;

    user->wealthRoot = malloc(sizeof(WealthNode));
    if (!user->wealthRoot) {
        free(user);
        printf("Memory allocation failed.\n");
        return NULL;
    }

    strcpy(user->wealthRoot->name, name);
    user->wealthRoot->value = 0.0;
    user->wealthRoot->firstChild = NULL;
    user->wealthRoot->nextSibling = NULL;

    printf("User '%s' registered successfully.\n", name);
    return user;
}

/* 5. Print all transactions from linked list */
void printExpenseLog(ExpenditureNode* head) {
    if (!head) {
        printf("No transactions found.\n");
        return;
    }
    printf("\n--- Transaction Log ---\n");
    for (ExpenditureNode* temp = head; temp; temp = temp->next)
        printf("[%s] %s - %.2f\n", temp->category, temp->description, temp->amount);
}

/* 6. Free all nodes in the linked list */
void freeExpenseList(ExpenditureNode* head) {
    ExpenditureNode* temp;
    while (head) {
        temp = head;
        head = head->next;
        free(temp);
    }
    printf("Expense list cleared successfully.\n");
}
